SUBROUTINE F (NEQ, x, Y, YDOT, RPAR, IPAR)
  use global
  implicit none
  integer :: NEQ, IPAR
  real*8 :: x, Y(NEQ), YDOT(NEQ), RPAR
  real*8 :: logrho, phidot
  
  logrho = Y(1)
  phidot = Y(2)
  
  YDOT(1) = -omegaz2*x - phidot
  YDOT(2) = exp(logrho)/bigQ
  
  return
end subroutine F

subroutine jac
  use global
  implicit none
  return
end subroutine jac

subroutine setup_isosg
  use global
  implicit none
  integer, parameter :: NEQ = 2, ITOL = 1 , MF = 10, LIW = 60, IOPT = 0
  integer, parameter :: LRW = 2*(20 + 16*NEQ)
  integer :: i, ITASK, ISTATE, IWORK(LIW), IPAR
  real*8, parameter :: RTOL = 1d-15, ATOL=1d-15
  real*8 :: Y(NEQ), x, xOUT, RWORK(LRW), RPAR
  external :: F, JAC
  
  Y(1) = 0d0 !log rho_hat = 0 at z=0
  Y(2) = 0d0 !dphi/dz =0 at z=0
  
  dnorm(1)   = 1d0
  drho(1)    = 0d0
  
  ITASK = 1
  ISTATE= 1
  
  do i = 1, nz-1
     x    = zaxis(i)
     xOUT = zaxis(i+1)
     
     call DVODE (F, NEQ, Y, x, xOUT, ITOL, RTOL, ATOL, ITASK, &
          ISTATE, IOPT, RWORK, LRW, IWORK, LIW, JAC, MF, &
          RPAR, IPAR)
     
     if(ISTATE .ne. 2) then
        print*, 'setup unsuccessful'
        stop
     endif
     
     dnorm(i+1) = exp(Y(1))
     drho(i+1)  = -omegaz2*zaxis(i+1) - Y(2)

  enddo
  d2rho= ( drho**2d0 - (omegaz2 + dnorm/bigQ)/fQ**2d0 )
  valf = 1d0/(beta*dnorm)
  csq  = 1d0 
  return
end subroutine setup_isosg

subroutine get_basic
  use global
  implicit none
  integer :: i 
  real*8, external :: density, dlogrho, resistivity, dresistivity, &
       d2resistivity 
  
  if(eos .eq. 'iso') then !isothermal 
     call setup_isosg
  else if(eos .eq. 'pol') then !n=1 polytrope 
     do i=1, nz 
        dnorm(i)   = density(zaxis(i)) 
        drho(i)    = dlogrho(zaxis(i)) 
     enddo
     d2rho = -(omegaz2 + dnorm/bigQ)/fQ**2d0
     d2rho = d2rho/dnorm 
     valf  = 1d0/(beta*dnorm) 
     csq   = dnorm  

  else if(eos .eq. 'uns') then !unstratified 
     dnorm = 1d0
     drho  = 0d0 
     csq   = 1d0
     valf  = 1d0/beta 
  endif
  
  if(beta .lt. 0d0) then !unmagnetized
     valf = 0d0 
  endif

!fill resistivity profile
  do i=1 , nz
     eta(i)  = resistivity(zaxis(i))
     deta(i) = dresistivity(zaxis(i))
     d2eta(i)= d2resistivity(zaxis(i))
  enddo

end subroutine get_basic


real*8 function density(znorm)
  !density normalized to midplane density, as function of normalized height
  !this is also cs^2/cs0^2
  use global
  implicit none
  real*8 :: ahat, omegaz2_Q, znorm 
  
  omegaz2_Q = omegaz2*bigQ
  ahat      = acos( omegaz2_Q/(omegaz2_Q + 1d0) )
  density   = (1d0 + omegaz2_Q)*cos(znorm*ahat) - omegaz2_Q
  return
end function density
 
real*8 function dlogrho(znorm)
  !dlog(rho)/dz (normalized units) 
  use global
  implicit none
  real*8 :: ahat, omegaz2_Q, znorm 
  real*8, external :: density 
  
  omegaz2_Q = omegaz2*bigQ
  ahat = acos( omegaz2_Q/(omegaz2_Q + 1d0) )
  dlogrho = -ahat*(1d0 + omegaz2_Q)*sin(znorm*ahat)/density(znorm) 
  return
end function dlogrho

real*8 function resistivity(znorm)
  use global
  implicit none
  real*8 :: znorm

  resistivity = 1d0/Rm
  return
end function resistivity

real*8 function dresistivity(znorm)
  use global
  implicit none
  real*8 :: znorm

  dresistivity = 0d0 
  return
end function dresistivity

real*8 function d2resistivity(znorm)
  use global
  implicit none
  real*8 :: znorm

  d2resistivity = 0d0 
  return
end function d2resistivity


subroutine chebyshev_poly(l, zbar, T_l, dT_l, d2T_l)
  implicit none
  real*8, intent(in) :: l, zbar
  real*8, intent(out):: T_l, dT_l, d2T_l
  real*8 :: t, lt, lsq

  lsq = l*l

  t  = acos(zbar)
  lt = l*t

  T_l = cos(lt)

  if(abs(zbar).lt.1d0) then
     dT_l = l*sin(lt)/sin(t)
     d2T_l= -lsq*cos(lt)/sin(t)**2 + l*cos(t)*sin(lt)/sin(t)**3
  else
     dT_l = lsq
     d2t_l =lsq*(lsq-1d0)/3d0
  endif

  return
end subroutine chebyshev_poly

subroutine construct_matrix(big_matrix) 
  use global
  implicit none 
  integer :: i 
  complex*16 :: L11(nz, nz), L12(nz, nz), L13(nz, nz), L14(nz, nz), &
       L15(nz, nz) 
  complex*16 :: L21(nz, nz), L22(nz, nz), L23(nz, nz), L24(nz, nz), &
       L25(nz, nz) 
  complex*16 :: L31(nz, nz), L32(nz, nz), L33(nz, nz), L34(nz, nz), &
       L35(nz, nz) 
  complex*16 :: L41(nz, nz), L42(nz, nz), L43(nz, nz), L44(nz, nz), &
       L45(nz, nz)
  complex*16 :: L51(nz, nz), L52(nz, nz), L53(nz, nz), L54(nz, nz), &
       L55(nz, nz)
  complex*16, intent(out) :: big_matrix(big_nz, big_nz) 
  complex*16 :: sbar , dsbar, isig, ifkx
  real*8 :: kxsq, fkx, rho, dden, fvasq, vasq, c2, c1, c0, kappa2
  real*8 :: Diff(nz)
  
  L11 = 0d0 ; L12 = 0d0 ; L13 = 0d0 ; L14 = 0d0 ; L15 = 0d0

  L21 = 0d0 ; L22 = 0d0 ; L23 = 0d0 ; L24 = 0d0 ; L25 = 0d0
  
  L31 = 0d0 ; L32 = 0d0 ; L33 = 0d0 ; L34 = 0d0 ; L35 = 0d0

  L41 = 0d0 ; L42 = 0d0 ; L43 = 0d0 ; L44 = 0d0 ; L45 = 0d0
 
  L51 = 0d0 ; L52 = 0d0 ; L53 = 0d0 ; L54 = 0d0 ; L55 = 0d0

  isig  = ii*sig 
  fkx   = fQ*kx
  ifkx  = ii*fkx 
  kxsq  = kx*kx 
  kappa2= kappa*kappa

  do i=1, nz-1
     rho  = dnorm(i)  
     dden = drho(i) !this is dlogrho/dz   
     vasq = valf(i)
     fvasq = fQ**2d0*vasq
     
     sbar  = sig - ii*eta(i)*kxsq
     dsbar = -ii*deta(i)*kxsq 

     c0 = beta*rho
     
     Diff(:) = d2rho(i)*T(i,:) + 2d0*drho(i)*Tp(i,:) + Tpp(i,:)

!EQ1, operators on vx 
!     L11(i,:) =   fQ**2d0*Tpp(i,:)/c0 - dsbar*fQ**2d0*Tp(i,:)/(sbar*c0) &
!                + eta(i)*isig*( d2rho(i)*T(i,:)    &
!                        + 2d0*drho(i)*Tp(i,:)    &
!                        +             Tpp(i,:) ) &   
!                +(2d0*deta(i) - eta(i)*dsbar/sbar)*isig*( drho(i)*T(i,:)  &
!                                                    +        Tp(i,:))&  
!                +(d2eta(i) - ii*sbar - deta(i)*dsbar/sbar)*isig*T(i,:) 

!      L11(i,:) = fQ**2d0*Tpp(i,:)/c0 + isig*eta(i)*(d2rho(i)*T(i,:) +&
!           & 2d0*drho(i)*Tp(i,:) + Tpp(i,:)) + sbar*sig*T(i,:)

       L11(i,:) = fQ**2d0*Tpp(i,:)/c0 + (sbar*sig - fQ**2d0*kxsq/c0 )*T(i,:) &
                 +ii*eta(i)*Diff(:)*sig 
 

!      L11(i,:) = vasq*( fQ*Tpp(i,:) + sig*sig*c0*T(i,:) )*fQ
!EQ1, operators on vy 
!     L12(i,:) =  -2d0*eta(i)*(  d2rho(i)*T(i,:) &
!                              + 2d0*drho(i)*Tp(i,:) &
!                              +    Tpp(i,:)       )&  
!                -2d0*(2d0*deta(i) - eta(i)*dsbar/sbar)*( drho(i)*T(i,:) &
!                                                     +Tp(i,:))       &
!                -2d0*(d2eta(i) - ii*sbar - deta(i)*dsbar/sbar)*T(i,:) 

!      L12(i,:) = -2d0*eta(i)*(d2rho(i)*T(i,:) + 2d0*drho(i)*Tp(i,:) + Tpp(i,:))  & 
!                 +2d0*ii*sbar*T(i,:)      

      L12(i,:) = -2d0*eta(i)*Diff(:) + 2d0*ii*sbar*T(i,:)
 

!      L12(i,:) =vasq*( 2d0*ii*sig*c0*T(i,:) )*fQ
!EQ1, operators on w
 !    L13(i,:) = eta(i)*ifkx*( d2rho(i)*T(i,:)  &
 !                            + 2d0*drho(i)*Tp(i,:) + Tpp(i,:) )&   
 !              +(2d0*deta(i) - eta(i)*dsbar/sbar)*ifkx*( drho(i)*T(i,:) &
 !                                                       +  Tp(i,:) )       &
 !              +(d2eta(i) - ii*sbar - deta(i)*dsbar/sbar)*ifkx*T(i,:) 

!      L13(i,:) = ifkx*eta(i)*(d2rho(i)*T(i,:) + 2d0*drho(i)*Tp(i,:) + Tpp(i,:)) &
!                 +sbar*fkx*T(i,:)

       L13(i,:) = ifkx*eta(i)*Diff(:) + fkx*sbar*T(i,:)
 

!      L13(i,:) = vasq*( sig*c0*fkx*T(i,:) )*fQ
!EQ1, operators on phi
      L14(i,:) = L13(i,:)
!EQ1, operators on bz
!      L15(i,:) =   eta(i)*ifkx*Tpp(i,:)/c0 &
!                + (2d0*deta(i) - eta(i)*dsbar/sbar)*ifkx*Tp(i,:)/c0 &
!                + (d2eta(i) - ii*sbar - deta(i)*dsbar/sbar)*ifkx*T(i,:)/c0 &
!                -ifkx*deta(i)*Tp(i,:)/c0 + (ifkx/c0)*(eta(i)*dsbar/sbar - d2eta(i) )*T(i,:)

!      L15(i,:) = ifkx*eta(i)*Tpp(i,:)/c0 + sbar*fkx*T(i,:)/c0

!     L15(i,:) = sig*kx*T(i,:)*fQ/c0

      

!EQ2, operators on vx 
!      L21(i,:) =  0.5d0*kappa2*eta(i)*( d2rho(i)*T(i,:) + 2d0*drho(i)*Tp(i,:) + Tpp(i,:) ) &
!                + 0.5d0*kappa2*(2d0*deta(i) - eta(i)*dsbar/sbar)*( drho(i)*T(i,:) + Tp(i,:) ) &
!                + 0.5*kappa2*(d2eta(i) - ii*sbar - deta(i)*dsbar/sbar)*T(i,:) &
!                +( sig*dsbar*shear*eta(i)/sbar**2d0 )*( drho(i)*T(i,:) +Tp(i,:) ) &     
!                +shear*(dsbar*deta(i)/(ii*sbar) - 1d0)*isig*T(i,:) &
!                +fQ*dsbar*shear*Tp(i,:)/(c0*ii*sbar**2d0) 
 
!      L21(i,:) = 0.5*kappa2*eta(i)*(d2rho(i)*T(i,:) +&
!           & 2d0*drho(i)*Tp(i,:) + Tpp(i,:) ) - isig*shear*T(i,:) &
!           &-0.5*ii*kappa2*sbar*T(i,:)


!      L21(i,:) = 0.5d0*eta(i)*kappa2*Diff(:) &
!                 +( ii*kxsq*shear*fQ**2d0/(sig*c0) - kxsq*shear*eta(i) - isig*shear -ii*sbar*kappa2/2d0)*T(i,:)
!      L21(i,:) = L21(i,:)*sig/shear    

       L21(i,:) = 0.5d0*eta(i)*kappa2*Diff(:)*sig/shear &
                 +( ii*kxsq*fQ**2d0/c0 - kxsq*sig*eta(i) - isig*sig -isig*sbar*kappa2/(2d0*shear) )*T(i,:)


!      L21(i,:) = ( -ii*sig*c0*(shear + kappa2/2d0)*T(i,:) )*vasq*sig
!EQ2, operators on vy
!      L22(i,:) = fQ**2d0*Tpp(i,:)/c0 - fQ**2d0*dsbar*Tp(i,:)/(sbar*c0)&
!                + isig*eta(i)*( d2rho(i)*T(i,:) + 2d0*drho(i)*Tp(i,:) + Tpp(i,:) ) &
!                + isig*(2d0*deta(i) - eta(i)*dsbar/sbar)*( drho(i)*T(i,:) + Tp(i,:) ) &
!                + isig*(d2eta(i) - ii*sbar -    deta(i)*dsbar/sbar)*T(i,:) &
!                -2d0*( dsbar*shear*eta(i)/(ii*sbar**2d0) )*(drho(i)*T(i,:) + Tp(i,:) ) &     
!                -2d0*shear*(dsbar*deta(i)/(ii*sbar) - 1d0)*T(i,:) 


!      L22(i,:) = fQ**2d0*Tpp(i,:)/c0 + isig*eta(i)*(d2rho(i)*T(i,:) +&
!           & 2d0*drho(i)*Tp(i,:) + Tpp(i,:) ) + 2d0*shear*T(i,:) & 
!           +sbar*sig*T(i,:)

!       L22(i,:) = fQ**2d0*Tpp(i,:)/c0 + isig*eta(i)*Diff(:) &
!                 +(2d0*shear + sbar*sig - 2d0*ii*kxsq*shear*eta(i)/sig)*T(i,:)
!       L22(i,:) = L22(i,:)*sig/shear

       L22(i,:) = fQ**2d0*Tpp(i,:)*sig/(c0*shear) + isig*eta(i)*Diff(:)*sig/shear &
                 +(2d0*sig + sbar*sig**2d0/shear - 2d0*ii*kxsq*eta(i))*T(i,:)

!      L22(i,:) = ( fQ*Tpp(i,:) +c0*(sig*sig + 2d0*shear)*T(i,:) )*vasq*sig
!EQ2, operators on w
!      L23(i,:) = ifkx*( dsbar*shear*eta(i)/(ii*sbar**2d0) )*(drho(i)*T(i,:) + Tp(i,:) ) &     
!                +ifkx*shear*(dsbar*deta(i)/(ii*sbar) - 1d0)*T(i,:) 

!      L23(i,:) = -shear*ifkx*T(i,:)

!      L23(i,:) = -ifkx*shear*sbar*T(i,:)/sig
!      L23(i,:) = L23(i,:)*sig/shear

       L23(i,:) = -ifkx*sbar*T(i,:)

!      L23(i,:) = ( -shear*c0*ii*fkx*T(i,:) )*vasq*sig
!EQ2, operators on phi
      L24(i,:) = L23(i,:)                 

      


!EQ2, operators on bz
!      L25(i,:) = ( dsbar*shear*eta(i)/(ii*sbar**2d0) )*ifkx*Tp(i,:)/c0     &
!                +shear*(dsbar*deta(i)/(ii*sbar) - 1d0)*ifkx*T(i,:)/c0 &
!                -dsbar*shear*fkx*eta(i)*T(i,:)/(c0*sbar**2d0) 

!      L25(i,:) = -ifkx*shear*T(i,:)/c0

!      L25(i,:) = L25(i,:)*sig

!      L25(i,:) = -shear*ii*kx*T(i,:)*vasq*sig

!EQ3

     L31(i,:) = (sig*kx/fQ)*T(i,:)
     L33(i,:) = Tpp(i,:) + dden*Tp(i,:) + ( (  sig**2d0/csq(i)   &  
                                             + rho/(csq(i)*bigQ))/fQ**2d0 )*T(i,:) 
     L34(i,:) = dden*Tp(i,:) + kxsq*T(i,:) 

!EQ4

     L43(i,:) = -T(i,:)*rho/(csq(i)*fQ**2d0*bigQ)
     L44(i,:) = Tpp(i,:) - kxsq*T(i,:)

!EQ5 
!     L51(i,:) = ii*fkx*T(i,:)
!     L55(i,:) = -eta(i)*Tpp(i,:) + ii*sbar*T(i,:)

!      L51(i,:) = fkx*T(i,:)
!      L55(i,:) = sig*T(i,:)


  enddo

!upper disk boundary conditions
  i = nz 
  rho  = dnorm(i)
  dden = drho(i)
  vasq = valf(i)
  fvasq = fQ**2d0*vasq

  if((eos.eq.'pol').or.(eos.eq.'iso')) then
     L11(i,:) = Tp(i,:) !dvx/dz = 0
     L22(i,:) = Tp(i,:) !dvy/dz = 0 
  
     L33(i,:) = Tp(i,:) !these two imply dw/dz + dphi/dz = 0 => vz=0 
     L34(i,:) = Tp(i,:) 
     
     L44(i,:) = Tp(i,:) + kx*T(i,:) !goldreich and lynden-bell potential bc 

!     L55(i,:) = Tp(i,:)
     
!!$     !zero lagragian total press. pert. 
!!$     L31(i,:) = -vasq*fkx*T(i,:)*sig
!!$     L33(i,:) = fQ*fQ*dden*csq(i)*Tp(i,:) + T(i,:)*sig**2d0 
!!$     L34(i,:) = fQ*fQ*dden*csq(i)*Tp(i,:)
!!$     
!!$     !goldreich/lynden-bell bc
!!$     L43(i,:) = -(rho/bigQ)*Tp(i,:)
!!$     L44(i,:) = (sig**2d0 - rho/bigQ)*Tp(i,:) + kx*T(i,:)*sig**2d0 
  endif
  
  if(eos.eq.'uns') then !then no gradient at top
     L11(i,:) = Tp(i,:)
     L22(i,:) = Tp(i,:)
     L33(i,:) = Tp(i,:)
     L44(i,:) = Tp(i,:)
  endif
  
  
!put small matrices into big matrix
   big_matrix = 0d0 

   big_matrix(1:nz, 1:nz)         = L11!*sig
   big_matrix(1:nz, nz+1 : 2*nz)  = L12!*sig
   big_matrix(1:nz, 2*nz+1:3*nz)  = L13!*sig
   big_matrix(1:nz, 3*nz+1:4*nz)  = L14!*sig 
!   big_matrix(1:nz, 4*nz+1:5*nz)  = L15!*sig 

   big_matrix(nz+1:2*nz, 1:nz)         = L21!*kx
   big_matrix(nz+1:2*nz, nz+1 : 2*nz)  = L22!*kx
   big_matrix(nz+1:2*nz, 2*nz+1:3*nz)  = L23!*kx
   big_matrix(nz+1:2*nz, 3*nz+1:4*nz)  = L24!*kx
!   big_matrix(nz+1:2*nz, 4*nz+1:5*nz)  = L25!*kx

   big_matrix(2*nz+1:3*nz, 1:nz)         = L31
   big_matrix(2*nz+1:3*nz, 2*nz+1:3*nz)  = L33
   big_matrix(2*nz+1:3*nz, 3*nz+1:4*nz)  = L34

   big_matrix(3*nz+1:4*nz, 2*nz+1:3*nz)  = L43
   big_matrix(3*nz+1:4*nz, 3*nz+1:4*nz)  = L44

!   big_matrix(4*nz+1:5*nz, 1:nz)         = L51!*sig
!   big_matrix(4*nz+1:5*nz, 4*nz+1:5*nz)  = L55!*sig
   

  return
end subroutine construct_matrix


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


subroutine eigenvalue_problem(output)
  use global
  implicit none 
  real*8, intent(out) :: output(2)
  integer :: info, loc(1) 
  complex*16 :: input(big_nz, big_nz), big_matrix(big_nz, big_nz)
  complex*16 :: fsigma, w(big_nz), vl(big_nz, big_nz), & 
       vr(big_nz,big_nz), work2(4*big_nz)  
  real*8 :: rwork2(2*big_nz), absw(big_nz) 
  complex*16 :: work(3*big_nz)
  complex*16 :: U(1,big_nz), VT(big_nz, big_nz),Mwvec(big_nz)
  real*8 :: singular(big_nz), rwork(5*big_nz), w2
  complex*16, external :: ZDOTC
  
  call construct_matrix(big_matrix)
  input = big_matrix  
  
  if(method .eq. 'eig') then 
     call zgeev('N', 'V', big_nz, input, big_nz, w, vl, big_nz, vr, big_nz, work2, & 
          4*big_nz, rwork2 , info) 
     absw= abs(w)
     loc = minloc(absw)
     fsigma = w(loc(1))/maxval(absw) 
     wvector = vr(:,loc(1)) 
  else if(method .eq. 'svd') then 
     call ZGESVD('N', 'A', big_nz, big_nz, input, big_nz, singular, U, 1, VT, big_nz, &
          WORK, 3*big_nz, RWORK, INFO)
     wvector(:)     = conjg(VT(big_nz, :))
     w2   = ZDOTC(big_nz,wvector,1,wvector,1)
     call  ZGEMV('N',big_nz,big_nz,(1d0,0d0),big_matrix,big_nz,wvector,1,(0d0,0d0),Mwvec,1)
     fsigma = ZDOTC(big_nz,wvector,1,Mwvec,1)/w2 
!     print*, fsigma 
  endif
  
  output(1) = dble(fsigma)
  output(2) = dimag(fsigma)
  
  return
end subroutine eigenvalue_problem


subroutine svd_final_matrix 
  use global
  implicit none
  integer :: info 
  complex*16 :: input(big_nz, big_nz), big_matrix(big_nz, big_nz)
  complex*16 :: work(3*big_nz) 
  complex*16 :: U(1,big_nz), VT(big_nz, big_nz) 
  real*8 :: singular(big_nz), rwork(5*big_nz)  
  complex*16, external :: ZDOTC

  call construct_matrix(big_matrix)
  input = big_matrix
  call ZGESVD('N', 'N', big_nz, big_nz, input, big_nz, singular, U, 1, VT, big_nz, &
       WORK, 3*big_nz, RWORK, INFO)
  condition = minval(singular)/maxval(singular)
!  print*, 'cond=', condition
  return
end subroutine svd_final_matrix


SUBROUTINE FCN(N,X,FVEC,IFLAG)
  use global
  integer :: N, IFLAG
  real*8 :: X(N),FVEC(N)
  real*8 :: output(2), err_init(2)
  common /share/ err_init  
  
  output = 0d0 
  sig   = dcmplx(x(1), x(2))
  call eigenvalue_problem(output)
  output  = output/err_init 
  fvec(1) = output(1)
  fvec(2) = output(2) 
  
  RETURN
END SUBROUTINE FCN

subroutine get_eigenvalue
  use global
  implicit none 
  integer, parameter :: N = 2, LWA = N*(3*N+13)
  integer :: INFO 
  real*8, parameter :: TOL = 1d-15
  real*8 :: x(N) , fvec(N), wa(LWA) 
  real*8 :: err_init(2), output(2)
  external :: FCN 
  common /share/ err_init 
 
  output = 0d0 
  !call to get initial error 
  call eigenvalue_problem(output)
  err_init = dabs(output) 
  
  !iterate to get eigenvalue 
  x(1) = dble(sig)
  x(2) = dimag(sig)
  call HYBRD1(FCN,N,X,FVEC,TOL,INFO,WA,LWA)
  sig   = dcmplx(x(1), x(2))
  
  return  
end subroutine get_eigenvalue

subroutine maximize_growth_rate
  use global
  implicit none
  integer, parameter :: N=2 
  integer :: i, loc(1)
  real*8, parameter :: tol=1d-15, rate_lim=1d1
  real*8 :: output(N), a_x, b_x, rates(ntrials), dsig, &
       guess_growth
  complex*16 :: eigen(ntrials)
 
!  call eigenvalue_problem(output)
!  stop 

  !trial growth rate read in as table 
  if(refine .eqv. .true.) then
     
     sig = sig_trials(kcount) !dcmplx(0d0, dimag(sig_trials(k)))
     write(6,fmt='(A)') '---------- trial eigen ----------'
     write(6,fmt='(3(e10.3,x))') dble(sig), dimag(sig)
     call get_eigenvalue
     
  else  !trial growth rate divided uniformly between min and max rates
     eigen   = dcmplx(0d0, 0d0) 
     rates   = 0d0 
     
     a_x = -max_growth
     b_x = -min_growth
     dsig = (b_x - a_x)/(ntrials - 1d0) 
     
     do i=1, ntrials 
        guess_growth = a_x + dsig*dble(i) 
        sig = dcmplx(0d0, guess_growth)     

        call get_eigenvalue
        eigen(i) =  sig 
        rates(i) = -dimag(sig)
        
        call svd_final_matrix

        if( (condition .ge. tol) .or. (rates(i) .gt. rate_lim )) then
!        if(  condition .ge. tol ) then
           rates(i) = 0d0 
           if(prin .eqv. .true.) write(6,fmt='(A,I3,2(e22.15))') 'REJECT  ',i,condition,rates(i)
        else
           if(prin .eqv. .true.) write(6,fmt='(A,I3,2(e22.15))') 'accept  ',i,condition, rates(i)
        endif      

     enddo
      
     loc = maxloc(rates)
     sig = eigen(loc(1))
  endif
  
  !get eigenfunctions
  call eigenvalue_problem(output)
  vx(:)  = wvector(1:nz)
  vy(:)  = wvector(nz+1:2*nz)
  den(:) = wvector(2*nz+1:3*nz)
  pot(:) = wvector(3*nz+1:4*nz)
!  bz(:)  = wvector(4*nz+1:big_nz)
  
  call svd_final_matrix 
  
  write(6,fmt='(A)') '---------- sig_re, sig_im, inv. cond. no. ----------'
  write(6,fmt='(3(e10.3,x))') dble(sig), dimag(sig), condition 
  write(6,fmt='(A)') '----------------------------------------------------' 
end subroutine maximize_growth_rate
